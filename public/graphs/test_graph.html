<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Graph Test</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #graph {
            border: 1px solid #ccc;
            background: #f9f9f9;
        }
        .node {
            cursor: pointer;
            stroke: #fff;
            stroke-width: 1px;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        #status {
            margin: 10px 0;
            padding: 10px;
            background: #e9e9e9;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Simple Graph Test - Chapter 11</h1>
    <div id="status">Loading...</div>
    <button onclick="loadGraph()">Load Chapter 11 Graph</button>
    <a href="http://localhost:9000/graphs/chapter_graph_viewer.html" target="_blank">Open Main Viewer</a>
    <div style="margin: 20px 0;">
        <strong>Expected:</strong> 14 axioms (blue), 16 predicates (green/purple/brown), 3 variables (pink), 81 connections
    </div>
    <svg id="graph" width="800" height="600"></svg>

    <script>
        let graphData = null;

        async function loadGraph() {
            const status = document.getElementById('status');

            try {
                status.innerHTML = 'Loading chapter 11 data...';

                const response = await fetch('/graphs/chapter_11_chapter_11_defeasibility_graph.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                graphData = await response.json();
                status.innerHTML = `✅ Loaded: ${graphData.graph.nodes.length} nodes, ${graphData.graph.links.length} links`;

                console.log('Graph data loaded:', graphData);
                console.log('Metadata:', graphData.metadata);
                console.log('First node:', graphData.graph.nodes[0]);
                console.log('First link:', graphData.graph.links[0]);

                createVisualization();

            } catch (error) {
                status.innerHTML = `❌ Error: ${error.message}`;
                console.error('Load error:', error);
            }
        }

        function createVisualization() {
            if (!graphData) return;

            const svg = d3.select('#graph');
            const width = 800;
            const height = 600;

            // Clear existing content
            svg.selectAll('*').remove();

            const nodes = graphData.graph.nodes;
            const links = graphData.graph.links;

            console.log(`Creating visualization: ${nodes.length} nodes, ${links.length} links`);

            // Create simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(50))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(20));

            // Create links
            const link = svg.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('class', 'link')
                .attr('stroke', d => {
                    if (d.type === 'uses_predicate') return '#666';
                    if (d.type === 'has_variable') return '#999';
                    if (d.type === 'co_occurs') return '#ccc';
                    return '#999';
                })
                .attr('stroke-width', 1);

            // Create nodes
            const node = svg.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('class', 'node')
                .attr('r', d => {
                    if (d.type === 'axiom') return 8;
                    if (d.type === 'predicate') return 6;
                    return 5;
                })
                .attr('fill', d => {
                    if (d.type === 'axiom') {
                        if (d.complexity === 'simple') return '#1f77b4';
                        if (d.complexity === 'moderate') return '#ff7f0e';
                        if (d.complexity === 'complex') return '#d62728';
                    }
                    if (d.type === 'predicate') {
                        if (d.importance === 'high') return '#2ca02c';
                        if (d.importance === 'medium') return '#9467bd';
                        return '#8c564b';
                    }
                    if (d.type === 'variable') return '#e377c2';
                    return '#999';
                })
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add labels
            const text = svg.append('g')
                .attr('class', 'labels')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .text(d => d.name.length > 12 ? d.name.substring(0, 10) + '...' : d.name)
                .attr('font-size', '10px')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .attr('pointer-events', 'none');

            // Add tooltips
            node.append('title')
                .text(d => `${d.name}\nType: ${d.type}\n${d.complexity ? 'Complexity: ' + d.complexity : ''}`);

            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                text
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Auto-load on page load
        window.addEventListener('load', loadGraph);
    </script>
</body>
</html>